#include "arg_parser.h"
#include "kpool_merge.h"
#include "kpool_filter.h"


// Argument parsing main function
inline Parameters parse_args(int& argc, char** argv) {

    CLI::App parser {""};  // Parser instance from CLI App parser
    Parameters parameters;

    std::shared_ptr<CustomFormatter> formatter(new CustomFormatter);

    // Main parser options
    parser.formatter(formatter);  // Set custom help format defined above
    parser.require_subcommand();  // Check that there is a subcommand
    parser.failure_message(failure_message);  // Formatting for error message

    CLI::App* merge = parser.add_subcommand("merge", "Merge two kmer counts tables generated by Jellyfish");
    CLI::App* filter = parser.add_subcommand("filter", "Filter a merged kmer counts table to find pool-specific kmers");

    // Options for 'merge'
    merge->add_option("KMER_TABLE_1", parameters.table1_file_path, "Path to the first Jellyfish kmer counts table")->required()->check(CLI::ExistingFile);
    merge->add_option("KMER_TABLE_2", parameters.table2_file_path, "Path to the second Jellyfish kmer counts table")->required()->check(CLI::ExistingFile);
    merge->add_option("OUTPUT_FILE", parameters.output_file_path, "Path to the output file (merged kmer counts table)")->required();
    merge->add_option("--tmp-prefix. -t", parameters.tmp_file_prefix, "Prefix for temporary index files (directories need to exist)", true);
    merge->add_option("--pool1, -p", parameters.pool1_id, "Name of the pool for the first table", true);
    merge->add_option("--pool2, -q", parameters.pool2_id, "Name of the pool for the second table", true);

    // Options for 'filter'
    filter->add_option("KMER_TABLE", parameters.input_file_path, "Path to a merged Jellyfish kmer counts table generated by kpool merge")->required()->check(CLI::ExistingFile);
    filter->add_option("OUTPUT_PREFIX", parameters.output_prefix, "Prefix for output files (filtered kmers for each pool)")->required();
    filter->add_option("--single-pool, -s", parameters.pool_to_filter, "Only output filtered kmers for specified pool", true);
    filter->add_option("--min-presence-depth, -d", parameters.min_kmer_presence_depth, "Minimum depth to consider a kmer present in the focal pool", true);
    filter->add_option("--max-presence-depth, -e", parameters.max_kmer_presence_depth, "Maximum depth to consider a kmer present in the focal pool", true);
    filter->add_option("--max-absence-depth, -a", parameters.max_kmer_absence_depth, "Maximum depth to consider a kmer absent in the other pool", true);

    // The parser throws an exception upon failure and implements an exit() method which output an error message and returns the exit code.
    try {

        parser.parse(argc, argv);

    } catch (const CLI::ParseError &e) {

        if (parser.get_subcommands().size() > 0) {

            std::string tmp = "";
            for (auto opt: parser.get_subcommands()[0]->get_options()) {
                tmp = opt->get_name();
                if (tmp.size() > formatter->column_widths[0]) formatter->column_widths[0] = static_cast<uint>(tmp.size());
                tmp = opt->get_type_name();
                if (tmp.size() > formatter->column_widths[1]) formatter->column_widths[1] = static_cast<uint>(tmp.size());
                tmp = opt->get_description();
                if (tmp.size() > formatter->column_widths[2]) formatter->column_widths[2] = static_cast<uint>(tmp.size());
            }

        } else {
            formatter->column_widths[0] = 10;
            formatter->column_widths[1] = 0;
            formatter->column_widths[2] = 50;
        }

        exit(parser.exit(e));

    }

    // Get subcommand name
    CLI::App* subcommand = parser.get_subcommands()[0];
    parameters.command = subcommand->get_name();

    return parameters;
}


int main(int argc, char* argv[]) {


    /* Kpool is a class that controls the entire programme
     * This class creates one object for each type of analysis.
     * Each analysis object will has its own parser to handle its specific arguments.
     * During initialization, the main parser is first run to check the type of analysis selected,
     * then the analysis-specific parser is run to parser the analysis-specific arguments.
     */

    Parameters parameters = parse_args(argc, argv);

    if (parameters.command == "merge") {

        kpool_merge(parameters);

    } else if (parameters.command == "filter") {

        kpool_filter(parameters);
    }

    return 0;
}
