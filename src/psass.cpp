#include "arg_parser.h"
#include "parameters.h"
#include "pileup_converter.h"
#include "pileup.h"
#include "analyze.h"

// Argument parsing main function
inline Parameters parse_args(int& argc, char** argv) {

    CLI::App parser {""};  // Parser instance from CLI App parser
    Parameters parameters;

    std::shared_ptr<CustomFormatter> formatter(new CustomFormatter);

    // Main parser options
    parser.formatter(formatter);  // Set custom help format defined above
    parser.require_subcommand();  // Check that there is a subcommand
    parser.failure_message(failure_message);  // Formatting for error message

    CLI::App* analyze = parser.add_subcommand("analyze", "Compute metrics from a sync file generated with psass pileup or by popoolation2 mpileup2sync");
    CLI::App* convert = parser.add_subcommand("convert", "Convert a pileup file from samtools to a synchronized pool file (deprecated, use psass pileup)");
    CLI::App* pileup = parser.add_subcommand("pileup", "Generate a psass pileup file from several alignment files");

    // Options for 'analyze'
    analyze->add_option("INPUT_FILE", parameters.input_file_path, "Path to a sync file generated by psass pileup or popoolation2")->required()->check(CLI::ExistingFile);
    analyze->add_option("OUTPUT_FILE", parameters.output_file_path, "Path to an output file for sliding window metrics")->required();

    analyze->add_option("--pool1, -p", parameters.pool1_id, "Name of the first pool (order in the pileup file)", true)->group("Input/Output");
    analyze->add_option("--pool2, -q", parameters.pool2_id, "Name of the second pool (order in the pileup file)", true)->group("Input/Output");
    analyze->add_flag("--popoolation", parameters.popoolation_format, "If set, assumes the input file was generated with popoolation2")->group("Input/Output");
    analyze->add_option("--snp-file, -s", parameters.snp_pos_file_path, "Output sex-biased SNPs to this file", true)->group("Input/Output");
    analyze->add_option("--fst-file, -f", parameters.fst_pos_file_path, "Output high FST positions to this file", true)->group("Input/Output");
    CLI::Option* gff_opt = analyze->add_option("--genes-file, -g", parameters.genes_file_path, "Output gene metrics to this file (requires a GFF file)", true)->group("Input/Output");
    CLI::Option* gene_opt = analyze->add_option("--gff-file, -G", parameters.gff_file_path, "Path to a GFF file for gene-specific output", true)->group("Input/Output");
    gff_opt->needs(gene_opt);

    analyze->add_option("--min-depth, -d", parameters.min_depth, "Minimum depth to include a site in the analyses", true)->group("Analysis");
    analyze->add_option("--window-size, -w", parameters.window_size, "Size of the sliding window (in bp)", true)->group("Analysis");
    analyze->add_option("--output-resolution, -r", parameters.output_resolution, "Output resolution for sliding window metrics (in bp)", true)->group("Analysis");
    analyze->add_option("--freq-het, -e", parameters.freq_het, "Frequency of a sex-linked SNP in the heterogametic sex", true)->group("Analysis");
    analyze->add_option("--range-het, -u", parameters.range_het, "Range of frequency for a sex-linked SNP in the heterogametic sex", true)->group("Analysis");
    analyze->add_option("--freq-hom, -o", parameters.freq_hom, "Frequency of a sex-linked SNP in the homogametic sex", true)->group("Analysis");
    analyze->add_option("--range-hom, -v", parameters.range_hom, "Range of frequency for a sex-linked SNP in the homogametic sex", true)->group("Analysis");
    analyze->add_option("--min-fst, -t", parameters.min_fst, "Minimum FST to output a site in the FST positions file", true)->group("Analysis");
    analyze->add_flag("--group-snps", parameters.group_snps, "If set, group consecutive snps to count them as a single polymorphism")->group("Analysis");

    // Options for 'convert'
    convert->add_option("INPUT", parameters.input_file_path, "Either a path to a samtools pileup output file or \"-\" for stdin")->required();
    convert->add_option("--output-file, -o", parameters.output_file_path, "Write to an output file instead of stdout");

    // Options for 'pileup'
    pileup->add_option("ALIGNMENT_FILES", parameters.alignment_files, "Alignment files to include in pileup, in bam or cram format and indexed")->required()->check(CLI::ExistingFile);
    pileup->add_option("--reference, -r", parameters.reference_file, "Reference file in fasta format, required with CRAM input files", true)->check(CLI::ExistingFile);
    pileup->add_option("--output-file, -o", parameters.output_file_path, "Write to an output file instead of stdout");
    pileup->add_option("--min-map-quality, -q", parameters.min_mapping_quality, "Minimum mapping quality to include a read in pileup", true);

    // The parser throws an exception upon failure and implements an exit() method which output an error message and returns the exit code.
    try {

        parser.parse(argc, argv);

    } catch (const CLI::ParseError &e) {

        if (parser.get_subcommands().size() > 0) {

            formatter->set_column_widths(parser);

        } else {

            formatter->column_widths[0] = 10;
            formatter->column_widths[1] = 0;
            formatter->column_widths[2] = 50;

        }

        exit(parser.exit(e));

    }

    // Set some parameter values after parsing
    parameters.window_range = static_cast<uint>(parameters.window_size / 2);
    parameters.min_het = parameters.freq_het - parameters.range_het;
    parameters.max_het = parameters.freq_het + parameters.range_het;
    parameters.min_hom = parameters.freq_hom- parameters.range_hom;

    // Get subcommand name
    CLI::App* subcommand = parser.get_subcommands()[0];
    parameters.command = subcommand->get_name();

    return parameters;
}


int main(int argc, char *argv[]) {

    Parameters parameters = parse_args(argc, argv);

    if (parameters.command == "analyze") {

        Psass psass(parameters);
        psass.run();

    } else if (parameters.command == "convert") {

        PileupConverter pileup_converter(parameters);
        pileup_converter.run();

    } else if (parameters.command == "pileup") {

        pileup(parameters);

    }

    return 0;
}
